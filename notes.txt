对于在state对象中给定一个属性（count:100），而在用到mutation方法对它进行算术操作时在vue页面渲染中并没有同步进行数字的更替现况（相反如果是一个数组当中的数字则是可以进行实时的算术运算并可以实时渲染的，其用到了map（）或者forEach（）这些处理数组数据的方法，而单个的数字没有这些方法的加持），到目前为止还没有得出相应的可靠结论。

用this.$el.querySelector('')可以获得相应的元素。

点击头像更换成另一头像，并且在浏览器刷新之后依然保存不会被刷掉（即将换掉的图片保存到了本地存储中），么有接口数据存储在本地。这个实现到了可以更换头像的部分，而没有存储到本地，当重新刷新页面或者加载时会失去刚换的新图片。这部分用的是fileReader这个原生api。
一段时间之后利用location.reload()重新加载更换图片后的页面（即当用户出发更换照片完成时即重新刷新页面）此时就会同步到所有的页面这个头像照片。

安装vue项目运行环境（全局范围）：
1、安装node.js （百度下载安装包以及阅读安装教程）
2、npm i -g cnpm （使用淘宝镜像，国内npm）
3、npm i -g vue-cli （安装vue的脚手架）
4、vue init webpack project （新目录下创建新的vue项目）
5、cnpm run dev（一般项目所有环境搭好之后的运行code）

对于已经安装过vue-cli脚手架的环境，运行clone过来的项目时：cnpm i

安装sass预编译器：
cnpm i node-sass --save-dev
cnpm i sass-loader --save-dev

安装axios http的请求：
cnpm i axios

安装lib-flexible（即使用rem单位来适配移动端）：
cnpm i lib-flexible --save

安装模拟数据mockjs（模拟后台接口数据）
cnpm i mockjs

安装上拉刷新下拉加载的插件
cnpm i vue-scroller -D

安装移动端的滚动插件
cnpm i better-scroll -s

关于跨域的一些笔记：
导致跨域的出现――浏览器的同源策略（协议、域名、端口）
csrf攻击（跨站请求伪造），攻击者盗用身份信息（即自己的帐号被盗了）
xss攻击（跨站脚本攻击），网页中嵌入脚本进行相应攻击
处理跨域的方法，jsonp，空iframe加form，cors，
axios、vue-resource都可获取接口数据，即响应http请求，vue2.0之后推荐使用axios

利用git上传vue项目至github的步骤：
1、git Bash Here（git安装完成后在项目目录下右键）
2、git init（初始化git）
3、git add . （将项目所有文件添加至仓库）
4、git commit -m "注释内容"（添加标注的内容）
5、（初次安装git此处会提示输入email和name,这里按需输入即可）
6、登录github帐号创建一个同项目名的仓库
7、复制所创建仓库的http地址（ssh没用过）
8、git remote add origin http:...（地址）
9、（这里会弹出登录gitub的登录框，按需输入即可）
10、git push -u origin master（上传本地项目，完成后github里面刷新即可出现）

再新机器（电脑）上关联自己github仓库上的项目：（电脑已经装好git）
1、Windows（桌面）下打开git bash（右键即可看见），输入ssh-keygen -t rsa -C "youremail@example.com"（github同注册的邮箱地址）
2、之后一路回车等待执行完毕。
3、github上进入到add ssh key界面，填上title，key中填上id_rsa.pub文件里面的内容。
4、id_rsa.pub进入方式=> C:\Users\Administrator\.ssh这个目录（即用户主目录）
5、选择需要克隆的仓库：git clone ssh地址。

廖雪峰的官方网站学习git教程学习笔记：
git，分布式版本控制系统，使用c语言开发。

cvs、svn是集中式版本控制系统，git为分布式版本控制系统。

集中式，必须要联网使用，版本库集中存放在中央处理器上，
每次需要操作更改时都需要先从中央处理器中下载更新到本地，然后进行操作，之后当自己修改完毕再上传至中央处理器更新当前自己所更改的版本。

分布式，不需要联网，版本库就在自己的电脑上，修改可以互推送到对方。同时也可以存在一个中央处理器来存放提交这些修改，方便交换大家修改。分布式比集中式安全性高，集中式的中央出了问题大家都没法干活，而分布式由于版本库都在自己本地，不存在这种集体灭亡的问题。

所有版本控制系统只能跟踪文本文件的改动，即txt、网页、程序代码，不包括图片视频等媒体格式的二进制文件，这些文件版本控制系统只能知道文件大小的变化，并不能实际知道他们到底何处做了什么变化。而word文档也为二级制文件，如需保存它们更改的变化信息，需要保存为纯文本文件。

空白地方创建一个git空目录：（右键单击git bash here）
mkdir learngit //learngit为自定义目录名字（工作区）
cd learngit
pwd //用于显示当前目录

git init //创建一个可以管理的git仓库（生成一个隐藏的.git文件）

git add demo.txt //将文件添加至这个仓库
git commit -m "注释内容" //提交添加申请 并作出注释
git status //查看仓库的状态 是否需要进行添加或提交
git diff //查看仓库修改的内容

git log //查看提交的历史记录
git reset --hard HEAD^（commit_id） //返回上一个版本 
//HEAD表示当前版本，HEAD^为上一个版本，HEAD^^为上上个版本，HEAD~100为上100个版本, 同时commit_id为每次提交的版本号为十六进制非常大的数字
git reflog //查看命令历史 查找回退版本的commit_id

.git是git的版本库，里面存着暂存区、master分支以及它的第一个指针HEAD，使用git add添加文件时将添加至暂存区里，而后通过git commit将暂存区的文件提交到master分支

git checkout -- <filename> //当文件还没有add到暂存区时 使用这个命令进行撤销
git reset HEAD <filename> //当文件add到暂存区时 用这个命令撤销 再用上面的命令进行撤销工作区上的修改（git checkout -- <filename>）
//当文件修改提交到master时使用git reset --hard commit_id来进行撤销

rm //删除某文件 （只是删掉了工作区里的）
git rm <filename> //删除某文件 （删除掉了工作区里的 同时也添加到了暂存区里） 之后需要提交至版本库git commit -m ''
git checkout -- <filename> //误删文件之后可以从版本库里面还原

git clone <ssh> //克隆远程库 ssh为git默认的协议即git://开头 速度快 原生
git remote add origin <ssh> //关联远程库（此处使用ssh协议，github为代码库）
git push -u origin master //第一次向库里面推送内容会error 出入yes即可
git push origin master //之后每次向库里面推送内容 （master为主分支）

git branch //查看分支 有*的为当前分支
git checkout -b <name> //创建+切换分支（<name>为分支名字）
git branch <name> //创建分支 
git checkout <name> //切换到相应分支
git merge <name> //合并指定分支到当前分支
git branch -d <name> //删除分支

git merge --no-ff -m 'message' <name>
//普通模式合并提交 可以git log看见合并历史记录 而git merge为fast forward模式看不出曾经做过合并（指针都指向master）
git stash //手头工作需要保存时
git stash pop //回到保存的工作状态
git branch -D <name> //强行删除未保存的分支

git remote -v //查看远程库的详细信息
多人协作推送到远程仓库的操作：
1、用git push origin <name> 推送自己的提交
2、推送失败 则远程比你先提交 需要先本地更新 用git pull
3、合并 有冲突解决 在本地提交
4、继续git push origin <name>推送提交
5、第二步git pull失败，则本地分支与远程分支没有链接，需要git branch --set-upstream-to=origin/<name> <name>

git tag <name> //打标签 切换到相应的分支上
git tag //查看所有标签
git tag show <name> //查看指定标签的信息
git push origin <name> //推送本地标签至远程仓库
git push origin --tags //推送全部的本地标签至远程仓库
git tag -d <name> //删除一个本地标签
git push origin :refs/tags/<name> //删除一个远程标签

【日常笔记】
1、在element-ui插件中的table渲染接口上的时间戳，可以在slot-scope-'scope'的template标签中加如这个{{action.timeFormat(scope.row.time)}}（time即为从接口数据中返回的参数时间）即可完美转换接口的时间戳，不必再写转换时间戳的函数。
2、使用element组件中的多选框提取其中的值，若是对象则会失去效果（指的是checkbox-group，即多选框的集合）。这时可以使用单个的checkbox，在用v-for来循环，value来显示判断是否勾选，同时change事件来更改所勾选的checkbox。
3、在获取日期时间时，后半段的时间（小时、分钟和秒）可用toLocaleTimeString来实现。