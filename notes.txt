对于在state对象中给定一个属性（count:100），而在用到mutation方法对它进行算术操作时在vue页面渲染中并没有同步进行数字的更替现况（相反如果是一个数组当中的数字则是可以进行实时的算术运算并可以实时渲染的，其用到了map（）或者forEach（）这些处理数组数据的方法，而单个的数字没有这些方法的加持），到目前为止还没有得出相应的可靠结论。

用this.$el.querySelector('')可以获得相应的元素。

点击头像更换成另一头像，并且在浏览器刷新之后依然保存不会被刷掉（即将换掉的图片保存到了本地存储中），么有接口数据存储在本地。这个实现到了可以更换头像的部分，而没有存储到本地，当重新刷新页面或者加载时会失去刚换的新图片。这部分用的是fileReader这个原生api。
一段时间之后利用location.reload()重新加载更换图片后的页面（即当用户出发更换照片完成时即重新刷新页面）此时就会同步到所有的页面这个头像照片。

安装vue项目运行环境（全局范围）：
1、安装node.js （百度下载安装包以及阅读安装教程）
2、npm i -g cnpm （使用淘宝镜像，国内npm）
3、cnpm run dev（一般项目所有环境搭好之后的运行code）

对于已经安装过vue-cli脚手架的环境，运行新的项目时：
vue init webpack myproject

安装sass预编译器：
cnpm i node-sass --save-dev
cnpm i sass-loader --save-dev

安装axios http的请求：
cnpm i axios

安装lib-flexible（即使用rem单位来适配移动端）：
cnpm i lib-flexible --save

安装模拟数据mockjs（模拟后台接口数据）
cnpm i mockjs

安装上拉刷新下拉加载的插件
cnpm i vue-scroller -D

安装移动端的滚动插件
cnpm i better-scroll -s

关于跨域的一些笔记：
导致跨域的出现――浏览器的同源策略（协议、域名、端口）
csrf攻击（跨站请求伪造），攻击者盗用身份信息（即自己的帐号被盗了）
xss攻击（跨站脚本攻击），网页中嵌入脚本进行相应攻击
处理跨域的方法，jsonp，空iframe加form，cors，

axios、vue-resource都可获取接口数据，即响应http请求，vue2.0之后推荐使用axios

利用git上传vue项目至github的步骤：
1、git Bash Here（git安装完成后在项目目录下右键）
2、git init（初始化git）
3、git add . （将项目所有文件添加至仓库）
4、git commit -m "注释内容"（添加标注的内容）
5、（初次安装git此处会提示输入email和name,这里按需输入即可）
6、登录github帐号创建一个同项目名的仓库
7、复制所创建仓库的http地址（ssh没用过）
8、git remote add origin http:...（地址）
9、（这里会弹出登录gitub的登录框，按需输入即可）
10、git push -u origin master（上传本地项目，完成后github里面刷新即可出现）

云想衣裳花想容
春风拂槛露华浓
若非群玉山头见
会向瑶台月下逢

git，分布式版本控制系统，使用c语言开发。

cvs、svn是集中式版本控制系统，git为分布式版本控制系统。

集中式，必须要联网使用，版本库集中存放在中央处理器上，
每次需要操作更改时都需要先从中央处理器中下载更新到本地，然后进行操作，之后当自己修改完毕再上传至中央处理器更新当前自己所更改的版本。

分布式，不需要联网，版本库就在自己的电脑上，修改可以互推送到对方。同时也可以存在一个中央处理器来存放提交这些修改，方便交换大家修改。分布式比集中式安全性高，集中式的中央出了问题大家都没法干活，而分布式由于版本库都在自己本地，不存在这种集体灭亡的问题。

所有版本控制系统只能跟踪文本文件的改动，即txt、网页、程序代码，不包括图片视频等媒体格式的二进制文件，这些文件版本控制系统只能知道文件大小的变化，并不能实际知道他们到底何处做了什么变化。而word文档也为二级制文件，如需保存它们更改的变化信息，需要保存为纯文本文件。

廖雪峰的官方网站学习git教程学习笔记：
空白地方创建一个git空目录：（右键单击git bash here）
mkdir learngit //learngit为自定义目录名字（工作区）
cd learngit
pwd //用于显示当前目录

git init //创建一个可以管理的git仓库（生成一个隐藏的.git文件）

git add demo.txt //将文件添加至这个仓库
git commit -m "注释内容" //提交添加申请 并作出注释
git status //查看仓库的状态 是否需要进行添加或提交
git diff //查看仓库修改的内容

git log //查看提交的历史记录
git reset --hard HEAD^（commit_id） //返回上一个版本 
//HEAD表示当前版本，HEAD^为上一个版本，HEAD^^为上上个版本，HEAD~100为上100个版本, 同时commit_id为每次提交的版本号为十六进制非常大的数字
git reflog //查看命令历史 查找回退版本的commit_id

.git是git的版本库，里面存着暂存区、master分支以及它的第一个指针HEAD，使用git add添加文件时将添加至暂存区里，而后通过git commit将暂存区的文件提交到master分支

git checkout -- <filename> //当文件还没有add到暂存区时 使用这个命令进行撤销
git reset HEAD <filename> //当文件add到暂存区时 用这个命令撤销 再用上面的命令进行撤销工作区上的修改（git checkout -- <filename>）
//当文件修改提交到master时使用git reset --hard commit_id来进行撤销

rm //删除某文件 （只是删掉了工作区里的）
git rm <filename> //删除某文件 （删除掉了工作区里的 同时也添加到了暂存区里） 之后需要提交至版本库git commit -m ''
git checkout -- <filename> //误删文件之后可以从版本库里面还原

git remote add origin <ssh> //关联远程库（此处使用ssh协议，github为代码库）
git push -u origin master //第一次向库里面推送内容会error 出入yes即可
git push origin master //之后每次向库里面推送内容

git checkout -b <name> //git 创建+切换分支
git branch <name> //查看/创建 当前分支 有*的为当前分支
git checkout <name> //切换到相应分支（<>为分支名字）
git merge <name> //合并指定分支到当前分支
git branch -b <name> //删除分支

if you could see this message,you could create branch of git...